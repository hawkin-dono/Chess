[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "Game",
        "importPath": "alphazero.Game",
        "description": "alphazero.Game",
        "isExtraImport": true,
        "detail": "alphazero.Game",
        "documentation": {}
    },
    {
        "label": "Game",
        "importPath": "alphazero.Game",
        "description": "alphazero.Game",
        "isExtraImport": true,
        "detail": "alphazero.Game",
        "documentation": {}
    },
    {
        "label": "Game",
        "importPath": "alphazero.Game",
        "description": "alphazero.Game",
        "isExtraImport": true,
        "detail": "alphazero.Game",
        "documentation": {}
    },
    {
        "label": "NeuralNet",
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "isExtraImport": true,
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "alphazero.utils",
        "description": "alphazero.utils",
        "isExtraImport": true,
        "detail": "alphazero.utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "alphazero.utils",
        "description": "alphazero.utils",
        "isExtraImport": true,
        "detail": "alphazero.utils",
        "documentation": {}
    },
    {
        "label": "MCTS",
        "importPath": "alphazero.MCTS",
        "description": "alphazero.MCTS",
        "isExtraImport": true,
        "detail": "alphazero.MCTS",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "chess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "chess",
        "description": "chess",
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Move",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "scan_reversed",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Move",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "PAWN",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "QUEEN",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "KING",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "scan_reversed",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "PAWN",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "KNIGHT",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "BISHOP",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "ROOK",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "QUEEN",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "WHITE",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "BLACK",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "scan_reversed",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "Move",
        "importPath": "chess",
        "description": "chess",
        "isExtraImport": true,
        "detail": "chess",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "open_reader",
        "importPath": "chess.polyglot",
        "description": "chess.polyglot",
        "isExtraImport": true,
        "detail": "chess.polyglot",
        "documentation": {}
    },
    {
        "label": "zobrist_hash",
        "importPath": "chess.polyglot",
        "description": "chess.polyglot",
        "isExtraImport": true,
        "detail": "chess.polyglot",
        "documentation": {}
    },
    {
        "label": "open_tablebase",
        "importPath": "chess.syzygy",
        "description": "chess.syzygy",
        "isExtraImport": true,
        "detail": "chess.syzygy",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "Piece",
        "importPath": "GUI.piece",
        "description": "GUI.piece",
        "isExtraImport": true,
        "detail": "GUI.piece",
        "documentation": {}
    },
    {
        "label": "board",
        "importPath": "GUI.Board",
        "description": "GUI.Board",
        "isExtraImport": true,
        "detail": "GUI.Board",
        "documentation": {}
    },
    {
        "label": "AlphaZeroAI",
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "isExtraImport": true,
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "AlphaZeroAI",
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "isExtraImport": true,
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "start_screen",
        "importPath": "start_window",
        "description": "start_window",
        "isExtraImport": true,
        "detail": "start_window",
        "documentation": {}
    },
    {
        "label": "draw_board",
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "isExtraImport": true,
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "EndGameWindow",
        "importPath": "end_window",
        "description": "end_window",
        "isExtraImport": true,
        "detail": "end_window",
        "documentation": {}
    },
    {
        "label": "cow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cow",
        "description": "cow",
        "detail": "cow",
        "documentation": {}
    },
    {
        "label": "AlphaZeroAI",
        "kind": 6,
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "peekOfCode": "class AlphaZeroAI:\n    def __init__(self):\n        self.game = Game()\n        self.nnet: nn = nn(self.game)\n        if args.load_model:\n            self.nnet.load_checkpoint(args.load_folder_file[0], args.load_folder_file[1])\n        self.mcts = MCTS(self.game, self.nnet, args)\n    def get_best_move(self, board):\n        current_player = 1 if board.turn else -1\n        self.mcts = MCTS(self.game, self.nnet, args)",
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "peekOfCode": "def main():\n    ai = AlphaZeroAI()\n    board = chess.Board('1k6/6R1/3K4/8/8/8/8/8 w - - 0 1')\n    print(board)\n    while True:\n        move = ai.get_best_move(board)\n        board.push(chess.Move.from_uci(move))\n        print(board)\n        if board.is_game_over():\n            break",
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "peekOfCode": "log = logging.getLogger(__name__)\nargs = dotdict({\n    'numIters': 20,\n    # nums of playing multiple (parallel) games times\n    'numEps': 2,  # 20      # number of complete self-play prallel games to simulate during a new iteration.  \n    'num_parallel_games': 4,  #nums of parallel games at each episode       => self play numeps * num_parallel_games games\n    'tempThreshold': 15,        #\n    'updateThreshold': 0.51,     # During arena playoff, new neural net will be accepted if threshold or more of games are won.\n    'maxlenOfQueue': 20000,  # Number of game examples to train the neural networks.\n    'numMCTSSims': 800,          # Number of games moves for MCTS to simulate.",
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "alphazero.AlphaZeroAI",
        "description": "alphazero.AlphaZeroAI",
        "peekOfCode": "args = dotdict({\n    'numIters': 20,\n    # nums of playing multiple (parallel) games times\n    'numEps': 2,  # 20      # number of complete self-play prallel games to simulate during a new iteration.  \n    'num_parallel_games': 4,  #nums of parallel games at each episode       => self play numeps * num_parallel_games games\n    'tempThreshold': 15,        #\n    'updateThreshold': 0.51,     # During arena playoff, new neural net will be accepted if threshold or more of games are won.\n    'maxlenOfQueue': 20000,  # Number of game examples to train the neural networks.\n    'numMCTSSims': 800,          # Number of games moves for MCTS to simulate.\n    'arenaCompare': 4,         # Number of games to play during arena play to determine if new net will be accepted.",
        "detail": "alphazero.AlphaZeroAI",
        "documentation": {}
    },
    {
        "label": "Game",
        "kind": 6,
        "importPath": "alphazero.Game",
        "description": "alphazero.Game",
        "peekOfCode": "class Game():\n    \"\"\"\n    This class specifies the base Game class. To define your own game, subclass\n    this class and implement the functions below. This works when the game is\n    two-player, adversarial and turn-based.\n    Use 1 for player1 and -1 for player2.\n    See othello/OthelloGame.py for an example implementation.\n    \"\"\"\n    def __init__(self):\n        pass",
        "detail": "alphazero.Game",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "alphazero.Game",
        "description": "alphazero.Game",
        "peekOfCode": "def main():\n    ## test 1\n    game = Game()\n    board = game.getInitBoard()\n    print(board)\n    # print(game.getBoardSize())\n    # print(game.getActionSize())\n    ## test 2 get piece at position\n    # pos = (1, 0)\n    # print(game.get_piece_at(board, pos))",
        "detail": "alphazero.Game",
        "documentation": {}
    },
    {
        "label": "MCTS",
        "kind": 6,
        "importPath": "alphazero.MCTS",
        "description": "alphazero.MCTS",
        "peekOfCode": "class MCTS():\n    \"\"\"\n    This class handles the MCTS tree.\n    \"\"\"\n    def __init__(self, game, nnet, args):\n        self.game: Game = game\n        self.nnet = nnet\n        self.args = args\n        self.Qsa = {}  # stores Q values for s,a (as defined in the paper)\n        self.Nsa = {}  # stores #times edge s,a was visited",
        "detail": "alphazero.MCTS",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "alphazero.MCTS",
        "description": "alphazero.MCTS",
        "peekOfCode": "EPS = 1e-8\nlog = logging.getLogger(__name__)\nclass MCTS():\n    \"\"\"\n    This class handles the MCTS tree.\n    \"\"\"\n    def __init__(self, game, nnet, args):\n        self.game: Game = game\n        self.nnet = nnet\n        self.args = args",
        "detail": "alphazero.MCTS",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "alphazero.MCTS",
        "description": "alphazero.MCTS",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass MCTS():\n    \"\"\"\n    This class handles the MCTS tree.\n    \"\"\"\n    def __init__(self, game, nnet, args):\n        self.game: Game = game\n        self.nnet = nnet\n        self.args = args\n        self.Qsa = {}  # stores Q values for s,a (as defined in the paper)",
        "detail": "alphazero.MCTS",
        "documentation": {}
    },
    {
        "label": "OthelloNNet",
        "kind": 6,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "class OthelloNNet(nn.Module):\n    def __init__(self, game, args):\n        # game params\n        self.board_x, self.board_y = game.getBoardSize()\n        self.action_size = game.getActionSize()\n        self.args = args\n        super(OthelloNNet, self).__init__()\n        self.conv1 = nn.Conv2d(1, args.num_channels, 3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(args.num_channels, args.num_channels, 3, stride=1, padding=1)\n        self.conv3 = nn.Conv2d(args.num_channels, args.num_channels, 3, stride=1)",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "ResNet",
        "kind": 6,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "class ResNet(nn.Module):\n    def __init__(self, game, args):\n        super().__init__()\n        self.startBlock = nn.Sequential(\n            nn.Conv2d(in_channels=6, out_channels= args.num_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d( args.num_channels),\n            nn.ReLU(),\n        )\n        self.backBone = nn.ModuleList(\n            [ResBlock( args.num_channels) for i in range(args.num_resBlocks)]",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "kind": 6,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "class ResBlock(nn.Module):\n    def __init__(self, num_hidden):\n        super().__init__()\n        self.conv1 = nn.Conv2d(in_channels=num_hidden, out_channels=num_hidden, kernel_size=3, padding=1)\n        self.bn1 = nn.BatchNorm2d(num_features=num_hidden)\n        self.conv2 = nn.Conv2d(in_channels=num_hidden, out_channels=num_hidden, kernel_size=3, padding=1)\n        self.bn2 = nn.BatchNorm2d(num_features=num_hidden)\n    def forward(self, x):\n        residual = x \n        x = F.relu(self.bn1(self.conv1(x)))",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "NeuralNet",
        "kind": 6,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "class NeuralNet():\n    \"\"\"\n    This class specifies the base NeuralNet class. To define your own neural\n    network, subclass this class and implement the functions below. The neural\n    network does not consider the current player, and instead only deals with\n    the canonical form of the board.\n    See othello/NNet.py for an example implementation.\n    \"\"\"\n    def __init__(self, game):\n        self.game = game",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "count_parameters",
        "kind": 2,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "def count_parameters(model):\n        return sum(p.numel() for p in model.parameters() if p.requires_grad)\ndef main():\n    ##test base model\n    print(args.device)\n    game = Game()\n    # model = ResNet(game, args)\n    # print(model)\n    # model = NeuralNet(game)\n    # model = OthelloNNet(game, args)",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "def main():\n    ##test base model\n    print(args.device)\n    game = Game()\n    # model = ResNet(game, args)\n    # print(model)\n    # model = NeuralNet(game)\n    # model = OthelloNNet(game, args)\n    # board = game.getInitBoard()\n    # board = game.get_encoded_states(board)",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "alphazero.NeuralNet",
        "description": "alphazero.NeuralNet",
        "peekOfCode": "args = dotdict({\n    'lr': 0.001,\n    # 'weight_decay': 0.1,\n    'dropout': 0.3,\n    'epochs': 10,\n    'batch_size': 16, # 32,\n    # 'cuda': torch.cuda.is_available(),\n    'device': 'cuda' if torch.cuda.is_available() else 'cpu',\n    # 'device': 'cuda:1',\n    'num_channels': 128,",
        "detail": "alphazero.NeuralNet",
        "documentation": {}
    },
    {
        "label": "AverageMeter",
        "kind": 6,
        "importPath": "alphazero.utils",
        "description": "alphazero.utils",
        "peekOfCode": "class AverageMeter(object):\n    \"\"\"From https://github.com/pytorch/examples/blob/master/imagenet/main.py\"\"\"\n    def __init__(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n    def __repr__(self):\n        return f'{self.avg:.2e}'\n    def update(self, val, n=1):",
        "detail": "alphazero.utils",
        "documentation": {}
    },
    {
        "label": "dotdict",
        "kind": 6,
        "importPath": "alphazero.utils",
        "description": "alphazero.utils",
        "peekOfCode": "class dotdict(dict):\n    def __getattr__(self, name):\n        return self[name]",
        "detail": "alphazero.utils",
        "documentation": {}
    },
    {
        "label": "quiesecence",
        "kind": 2,
        "importPath": "cow._engine",
        "description": "cow._engine",
        "peekOfCode": "def quiesecence(board : Board, depth: int, MAX_DEPTH: int, is_end_game: bool, alpha: float, beta: float, turn: int):\n    if (depth < MAX_DEPTH):\n        if board.is_checkmate(): return -turn * (END_GAME_SCORE + END_GAME_SCORE / (board.fullmove_number + 1))\n        if board.is_insufficient_material(): return 0\n        if not any(board.generate_legal_moves()): return 0\n        if board.is_fifty_moves(): return 0\n        if board.is_repetition(3): return 0\n    if depth == 0: return -turn * score(board, is_end_game)\n    moves = organize_moves_quiescence(board)\n    if not moves: return -turn * score(board, is_end_game)",
        "detail": "cow._engine",
        "documentation": {}
    },
    {
        "label": "minimax",
        "kind": 2,
        "importPath": "cow._engine",
        "description": "cow._engine",
        "peekOfCode": "def minimax(board : Board, depth: int, cache: dict, is_end_game: bool, alpha: float = -float('inf'), beta: float = float('inf'), turn: int = 1):\n    if board.is_checkmate(): return None, -turn * (END_GAME_SCORE + END_GAME_SCORE / (board.fullmove_number + 1))\n    if board.is_insufficient_material(): return None, 0\n    if not any(board.generate_legal_moves()): return None, 0\n    if board.is_fifty_moves(): return None, 0\n    if board.is_repetition(3): return None, 0\n    cache_key = (zobrist_hash(board), (depth if depth >= 0 else 0), alpha, beta, turn)\n    if cache_key in cache: return cache[cache_key]\n    if depth <= 0: \n        eval = quiesecence(board, 12, 12, is_end_game, alpha, beta, turn)",
        "detail": "cow._engine",
        "documentation": {}
    },
    {
        "label": "OPENING_BOOK",
        "kind": 5,
        "importPath": "cow._engine",
        "description": "cow._engine",
        "peekOfCode": "OPENING_BOOK = open_reader(\"cow/data/opening_book/3210elo.bin\")\ndef quiesecence(board : Board, depth: int, MAX_DEPTH: int, is_end_game: bool, alpha: float, beta: float, turn: int):\n    if (depth < MAX_DEPTH):\n        if board.is_checkmate(): return -turn * (END_GAME_SCORE + END_GAME_SCORE / (board.fullmove_number + 1))\n        if board.is_insufficient_material(): return 0\n        if not any(board.generate_legal_moves()): return 0\n        if board.is_fifty_moves(): return 0\n        if board.is_repetition(3): return 0\n    if depth == 0: return -turn * score(board, is_end_game)\n    moves = organize_moves_quiescence(board)",
        "detail": "cow._engine",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "def score(board: Board, is_end_game: bool) -> float:\n    if is_end_game:\n        dtz = -EGTABLEBASE.get_dtz(board, 0)\n        if dtz > 0: return (END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n        if dtz < 0: return (-END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n    return calculate_score(board) \nPIECE_VALUES = [10, 30, 30, 50, 90, 1000]  # pawn, knight, bishop, rook, queen, king\ndef get_move_score(board: Board, move: Move) -> int:\n    if move.promotion == QUEEN: return 1\n    if board.is_capture(move): ",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "get_move_score",
        "kind": 2,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "def get_move_score(board: Board, move: Move) -> int:\n    if move.promotion == QUEEN: return 1\n    if board.is_capture(move): \n        if board.is_en_passant(move): return 0\n        if not any(board.attackers(not board.turn, move.to_square)): return PIECE_VALUES[board.piece_type_at(move.to_square) - 1]\n        return PIECE_VALUES[board.piece_type_at(move.to_square) - 1] - PIECE_VALUES[board.piece_type_at(move.from_square) - 1]\n    return (-2 * PIECE_VALUES[KING - 1]) + get_move_static_score(board, move)\ndef organize_moves_quiescence(board: Board) -> list[Move]:\n    return sorted([move for move in board.generate_legal_moves() if get_move_score(board, move) > 0],\n                   key=lambda move: get_move_score(board, move), reverse=True)",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "organize_moves_quiescence",
        "kind": 2,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "def organize_moves_quiescence(board: Board) -> list[Move]:\n    return sorted([move for move in board.generate_legal_moves() if get_move_score(board, move) > 0],\n                   key=lambda move: get_move_score(board, move), reverse=True)\ndef organize_moves(board: Board) -> list[Move]:\n    return sorted(board.generate_legal_moves(), key=lambda move: get_move_score(board, move), reverse=True)\ndef is_null_ok(board: Board) -> bool:\n    if board.is_check() or (board.peek == Move.null()): return False\n    for square in scan_reversed(board.occupied_co[board.turn]):\n        if board.piece_type_at(square) not in [KING, PAWN]:\n            return True",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "organize_moves",
        "kind": 2,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "def organize_moves(board: Board) -> list[Move]:\n    return sorted(board.generate_legal_moves(), key=lambda move: get_move_score(board, move), reverse=True)\ndef is_null_ok(board: Board) -> bool:\n    if board.is_check() or (board.peek == Move.null()): return False\n    for square in scan_reversed(board.occupied_co[board.turn]):\n        if board.piece_type_at(square) not in [KING, PAWN]:\n            return True\n    return False",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "is_null_ok",
        "kind": 2,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "def is_null_ok(board: Board) -> bool:\n    if board.is_check() or (board.peek == Move.null()): return False\n    for square in scan_reversed(board.occupied_co[board.turn]):\n        if board.piece_type_at(square) not in [KING, PAWN]:\n            return True\n    return False",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "END_GAME_SCORE",
        "kind": 5,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "END_GAME_SCORE = 10000000\nEGTABLEBASE = open_tablebase(\"cow/data/syzygy/3-4-5\")\ndef score(board: Board, is_end_game: bool) -> float:\n    if is_end_game:\n        dtz = -EGTABLEBASE.get_dtz(board, 0)\n        if dtz > 0: return (END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n        if dtz < 0: return (-END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n    return calculate_score(board) \nPIECE_VALUES = [10, 30, 30, 50, 90, 1000]  # pawn, knight, bishop, rook, queen, king\ndef get_move_score(board: Board, move: Move) -> int:",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "EGTABLEBASE",
        "kind": 5,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "EGTABLEBASE = open_tablebase(\"cow/data/syzygy/3-4-5\")\ndef score(board: Board, is_end_game: bool) -> float:\n    if is_end_game:\n        dtz = -EGTABLEBASE.get_dtz(board, 0)\n        if dtz > 0: return (END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n        if dtz < 0: return (-END_GAME_SCORE - dtz * 1000) + calculate_score(board) / 100\n    return calculate_score(board) \nPIECE_VALUES = [10, 30, 30, 50, 90, 1000]  # pawn, knight, bishop, rook, queen, king\ndef get_move_score(board: Board, move: Move) -> int:\n    if move.promotion == QUEEN: return 1",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "PIECE_VALUES",
        "kind": 5,
        "importPath": "cow._heuristic",
        "description": "cow._heuristic",
        "peekOfCode": "PIECE_VALUES = [10, 30, 30, 50, 90, 1000]  # pawn, knight, bishop, rook, queen, king\ndef get_move_score(board: Board, move: Move) -> int:\n    if move.promotion == QUEEN: return 1\n    if board.is_capture(move): \n        if board.is_en_passant(move): return 0\n        if not any(board.attackers(not board.turn, move.to_square)): return PIECE_VALUES[board.piece_type_at(move.to_square) - 1]\n        return PIECE_VALUES[board.piece_type_at(move.to_square) - 1] - PIECE_VALUES[board.piece_type_at(move.from_square) - 1]\n    return (-2 * PIECE_VALUES[KING - 1]) + get_move_static_score(board, move)\ndef organize_moves_quiescence(board: Board) -> list[Move]:\n    return sorted([move for move in board.generate_legal_moves() if get_move_score(board, move) > 0],",
        "detail": "cow._heuristic",
        "documentation": {}
    },
    {
        "label": "calculate_score",
        "kind": 2,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "def calculate_score(board: Board) -> float:\n    mg_score, eg_score = 0, 0\n    for square in scan_reversed(board.occupied_co[WHITE]):\n        piece_type = board.piece_type_at(square)\n        mg_score += MG_PESTO[piece_type - 1][square ^ 56] + MG_PIECE_VALUES[piece_type - 1]\n        eg_score += EG_PESTO[piece_type - 1][square ^ 56] + EG_PIECE_VALUES[piece_type - 1]\n    for square in scan_reversed(board.occupied_co[BLACK]):\n        piece_type = board.piece_type_at(square)\n        mg_score -= MG_PESTO[piece_type - 1][square] + MG_PIECE_VALUES[piece_type - 1]\n        eg_score -= EG_PESTO[piece_type - 1][square] + EG_PIECE_VALUES[piece_type - 1]",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "get_phase",
        "kind": 2,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "def get_phase(board: Board) -> float:\n    phase = TOTAL_PHASE - sum(PHASE_VALUES[board.piece_type_at(square) - 1] for square in scan_reversed(board.occupied))\n    return (phase * 256 + (TOTAL_PHASE / 2)) / TOTAL_PHASE",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "MG_PIECE_VALUES",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "MG_PIECE_VALUES = [82, 337, 365, 477, 1025, 24000]  # pawn, knight, bishop, rook, queen, king\nEG_PIECE_VALUES = [94, 281, 297, 512, 936, 24000]  # pawn, knight, bishop, rook, queen, king\nPAWN_MG = [0,   0,   0,   0,   0,   0,  0,   0,\n          98, 134,  61,  95,  68, 126, 34, -11,\n          -6,   7,  26,  31,  65,  56, 25, -20,\n         -14,  13,   6,  21,  23,  12, 17, -23,\n         -27,  -2,  -5,  12,  17,   6, 10, -25,\n         -26,  -4,  -4, -10,   3,   3, 33, -12,\n         -35,  -1, -20, -23, -15,  24, 38, -22,\n           0,   0,   0,   0,   0,   0,  0,   0,]",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "EG_PIECE_VALUES",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "EG_PIECE_VALUES = [94, 281, 297, 512, 936, 24000]  # pawn, knight, bishop, rook, queen, king\nPAWN_MG = [0,   0,   0,   0,   0,   0,  0,   0,\n          98, 134,  61,  95,  68, 126, 34, -11,\n          -6,   7,  26,  31,  65,  56, 25, -20,\n         -14,  13,   6,  21,  23,  12, 17, -23,\n         -27,  -2,  -5,  12,  17,   6, 10, -25,\n         -26,  -4,  -4, -10,   3,   3, 33, -12,\n         -35,  -1, -20, -23, -15,  24, 38, -22,\n           0,   0,   0,   0,   0,   0,  0,   0,]\nPAWN_EG = [0,   0,   0,   0,   0,   0,   0,   0,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "PAWN_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "PAWN_MG = [0,   0,   0,   0,   0,   0,  0,   0,\n          98, 134,  61,  95,  68, 126, 34, -11,\n          -6,   7,  26,  31,  65,  56, 25, -20,\n         -14,  13,   6,  21,  23,  12, 17, -23,\n         -27,  -2,  -5,  12,  17,   6, 10, -25,\n         -26,  -4,  -4, -10,   3,   3, 33, -12,\n         -35,  -1, -20, -23, -15,  24, 38, -22,\n           0,   0,   0,   0,   0,   0,  0,   0,]\nPAWN_EG = [0,   0,   0,   0,   0,   0,   0,   0,\n         178, 173, 158, 134, 147, 132, 165, 187,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "PAWN_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "PAWN_EG = [0,   0,   0,   0,   0,   0,   0,   0,\n         178, 173, 158, 134, 147, 132, 165, 187,\n          94, 100,  85,  67,  56,  53,  82,  84,\n          32,  24,  13,   5,  -2,   4,  17,  17,\n          13,   9,  -3,  -7,  -7,  -8,   3,  -1,\n           4,   7,  -6,   1,   0,  -5,  -1,  -8,\n          13,   8,   8,  10,  13,   0,   2,  -7,\n           0,   0,   0,   0,   0,   0,   0,   0,]\nKNIGHT_MG = [-167, -89, -34, -49,  61, -97, -15, -107,\n              -73, -41,  72,  36,  23,  62,   7,  -17,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "KNIGHT_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "KNIGHT_MG = [-167, -89, -34, -49,  61, -97, -15, -107,\n              -73, -41,  72,  36,  23,  62,   7,  -17,\n              -47,  60,  37,  65,  84, 129,  73,   44,\n               -9,  17,  19,  53,  37,  69,  18,   22,\n              -13,   4,  16,  13,  28,  19,  21,   -8,\n              -23,  -9,  12,  10,  19,  17,  25,  -16,\n              -29, -53, -12,  -3,  -1,  18, -14,  -19,\n             -105, -21, -58, -33, -17, -28, -19,  -23,]\nKNIGHT_EG = [-58, -38, -13, -28, -31, -27, -63, -99,\n             -25,  -8, -25,  -2,  -9, -25, -24, -52,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "KNIGHT_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "KNIGHT_EG = [-58, -38, -13, -28, -31, -27, -63, -99,\n             -25,  -8, -25,  -2,  -9, -25, -24, -52,\n             -24, -20,  10,   9,  -1,  -9, -19, -41,\n             -17,   3,  22,  22,  22,  11,   8, -18,\n             -18,  -6,  16,  25,  16,  17,   4, -18,\n             -23,  -3,  -1,  15,  10,  -3, -20, -22,\n             -42, -20, -10,  -5,  -2, -20, -23, -44,\n             -29, -51, -23, -15, -22, -18, -50, -64,]\nBISHOP_MG = [-29,   4, -82, -37, -25, -42,   7,  -8,\n             -26,  16, -18, -13,  30,  59,  18, -47,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "BISHOP_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "BISHOP_MG = [-29,   4, -82, -37, -25, -42,   7,  -8,\n             -26,  16, -18, -13,  30,  59,  18, -47,\n             -16,  37,  43,  40,  35,  50,  37,  -2,\n              -4,   5,  19,  50,  37,  37,   7,  -2,\n              -6,  13,  13,  26,  34,  12,  10,   4,\n               0,  15,  15,  15,  14,  27,  18,  10,\n               4,  15,  16,   0,   7,  21,  33,   1,\n             -33,  -3, -14, -21, -13, -12, -39, -21,]\nBISHOP_EG = [-14, -21, -11,  -8, -7,  -9, -17, -24,\n              -8,  -4,   7, -12, -3, -13,  -4, -14,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "BISHOP_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "BISHOP_EG = [-14, -21, -11,  -8, -7,  -9, -17, -24,\n              -8,  -4,   7, -12, -3, -13,  -4, -14,\n               2,  -8,   0,  -1, -2,   6,   0,   4,\n              -3,   9,  12,   9, 14,  10,   3,   2,\n              -6,   3,  13,  19,  7,  10,  -3,  -9,\n             -12,  -3,   8,  10, 13,   3,  -7, -15,\n             -14, -18,  -7,  -1,  4,  -9, -15, -27,\n             -23,  -9, -23,  -5, -9, -16,  -5, -17,]\nROOK_MG = [32,  42,  32,  51, 63,  9,  31,  43,\n           27,  32,  58,  62, 80, 67,  26,  44,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "ROOK_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "ROOK_MG = [32,  42,  32,  51, 63,  9,  31,  43,\n           27,  32,  58,  62, 80, 67,  26,  44,\n           -5,  19,  26,  36, 17, 45,  61,  16,\n          -24, -11,   7,  26, 24, 35,  -8, -20,\n          -36, -26, -12,  -1,  9, -7,   6, -23,\n          -45, -25, -16, -17,  3,  0,  -5, -33,\n          -44, -16, -20,  -9, -1, 11,  -6, -71,\n          -19, -13,   1,  17, 16,  7, -37, -26,]\nROOK_EG = [13, 10, 18, 15, 12,  12,   8,   5,\n           11, 13, 13, 11, -3,   3,   8,   3,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "ROOK_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "ROOK_EG = [13, 10, 18, 15, 12,  12,   8,   5,\n           11, 13, 13, 11, -3,   3,   8,   3,\n            7,  7,  7,  5,  4,  -3,  -5,  -3,\n            4,  3, 13,  1,  2,   1,  -1,   2,\n            3,  5,  8,  4, -5,  -6,  -8, -11,\n           -4,  0, -5, -1, -7, -12,  -8, -16,\n           -6, -6,  0,  2, -9,  -9, -11,  -3,\n           -9,  2,  3, -1, -5, -13,   4, -20,]\nQUEEN_MG = [-28,   0,  29,  12,  59,  44,  43,  45,\n            -24, -39,  -5,   1, -16,  57,  28,  54,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "QUEEN_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "QUEEN_MG = [-28,   0,  29,  12,  59,  44,  43,  45,\n            -24, -39,  -5,   1, -16,  57,  28,  54,\n            -13, -17,   7,   8,  29,  56,  47,  57,\n            -27, -27, -16, -16,  -1,  17,  -2,   1,\n             -9, -26,  -9, -10,  -2,  -4,   3,  -3,\n            -14,   2, -11,  -2,  -5,   2,  14,   5,\n            -35,  -8,  11,   2,   8,  15,  -3,   1,\n             -1, -18,  -9,  10, -15, -25, -31, -50,]\nQUEEN_EG = [-9,  22,  22,  27,  27,  19,  10,  20,\n           -17,  20,  32,  41,  58,  25,  30,   0,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "QUEEN_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "QUEEN_EG = [-9,  22,  22,  27,  27,  19,  10,  20,\n           -17,  20,  32,  41,  58,  25,  30,   0,\n           -20,   6,   9,  49,  47,  35,  19,   9,\n             3,  22,  24,  45,  57,  40,  57,  36,\n           -18,  28,  19,  47,  31,  34,  39,  23,\n           -16, -27,  15,   6,   9,  17,  10,   5,\n           -22, -23, -30, -16, -16, -23, -36, -32,\n           -33, -28, -22, -43,  -5, -32, -20, -41,]\nKING_MG = [-65,  23,  16, -15, -56, -34,   2,  13,\n            29,  -1, -20,  -7,  -8,  -4, -38, -29,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "KING_MG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "KING_MG = [-65,  23,  16, -15, -56, -34,   2,  13,\n            29,  -1, -20,  -7,  -8,  -4, -38, -29,\n            -9,  24,   2, -16, -20,   6,  22, -22,\n           -17, -20, -12, -27, -30, -25, -14, -36,\n           -49,  -1, -27, -39, -46, -44, -33, -51,\n           -14, -14, -22, -46, -44, -30, -15, -27,\n             1,   7,  -8, -64, -43, -16,   9,   8,\n           -15,  36,  12, -54,   8, -28,  24,  14,]\nKING_EG = [-74, -35, -18, -18, -11,  15,   4, -17,\n           -12,  17,  14,  17,  17,  38,  23,  11,",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "KING_EG",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "KING_EG = [-74, -35, -18, -18, -11,  15,   4, -17,\n           -12,  17,  14,  17,  17,  38,  23,  11,\n            10,  17,  23,  15,  20,  45,  44,  13,\n            -8,  22,  24,  27,  26,  33,  26,   3,\n           -18,  -4,  21,  24,  27,  23,   9, -11,\n           -19,  -3,  11,  21,  23,  16,   7,  -9,\n           -27, -11,   4,  13,  14,   4,  -5, -17,\n           -53, -34, -21, -11, -28, -14, -24, -43,]\nMG_PESTO = [PAWN_MG, KNIGHT_MG, BISHOP_MG, ROOK_MG, QUEEN_MG, KING_MG]\nEG_PESTO = [PAWN_EG, KNIGHT_EG, BISHOP_EG, ROOK_EG, QUEEN_EG, KING_EG]",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "MG_PESTO",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "MG_PESTO = [PAWN_MG, KNIGHT_MG, BISHOP_MG, ROOK_MG, QUEEN_MG, KING_MG]\nEG_PESTO = [PAWN_EG, KNIGHT_EG, BISHOP_EG, ROOK_EG, QUEEN_EG, KING_EG]\ndef calculate_score(board: Board) -> float:\n    mg_score, eg_score = 0, 0\n    for square in scan_reversed(board.occupied_co[WHITE]):\n        piece_type = board.piece_type_at(square)\n        mg_score += MG_PESTO[piece_type - 1][square ^ 56] + MG_PIECE_VALUES[piece_type - 1]\n        eg_score += EG_PESTO[piece_type - 1][square ^ 56] + EG_PIECE_VALUES[piece_type - 1]\n    for square in scan_reversed(board.occupied_co[BLACK]):\n        piece_type = board.piece_type_at(square)",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "EG_PESTO",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "EG_PESTO = [PAWN_EG, KNIGHT_EG, BISHOP_EG, ROOK_EG, QUEEN_EG, KING_EG]\ndef calculate_score(board: Board) -> float:\n    mg_score, eg_score = 0, 0\n    for square in scan_reversed(board.occupied_co[WHITE]):\n        piece_type = board.piece_type_at(square)\n        mg_score += MG_PESTO[piece_type - 1][square ^ 56] + MG_PIECE_VALUES[piece_type - 1]\n        eg_score += EG_PESTO[piece_type - 1][square ^ 56] + EG_PIECE_VALUES[piece_type - 1]\n    for square in scan_reversed(board.occupied_co[BLACK]):\n        piece_type = board.piece_type_at(square)\n        mg_score -= MG_PESTO[piece_type - 1][square] + MG_PIECE_VALUES[piece_type - 1]",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "PHASE_VALUES",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "PHASE_VALUES = [0, 1, 1, 2, 4, 0]\nTOTAL_PHASE = (PHASE_VALUES[PAWN - 1] * 16 + PHASE_VALUES[KNIGHT - 1] * 4 + \n               PHASE_VALUES[BISHOP - 1] * 4 + PHASE_VALUES[ROOK - 1] * 4 + PHASE_VALUES[QUEEN - 1] * 2)\ndef get_phase(board: Board) -> float:\n    phase = TOTAL_PHASE - sum(PHASE_VALUES[board.piece_type_at(square) - 1] for square in scan_reversed(board.occupied))\n    return (phase * 256 + (TOTAL_PHASE / 2)) / TOTAL_PHASE",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "TOTAL_PHASE",
        "kind": 5,
        "importPath": "cow._pesto_evaluation",
        "description": "cow._pesto_evaluation",
        "peekOfCode": "TOTAL_PHASE = (PHASE_VALUES[PAWN - 1] * 16 + PHASE_VALUES[KNIGHT - 1] * 4 + \n               PHASE_VALUES[BISHOP - 1] * 4 + PHASE_VALUES[ROOK - 1] * 4 + PHASE_VALUES[QUEEN - 1] * 2)\ndef get_phase(board: Board) -> float:\n    phase = TOTAL_PHASE - sum(PHASE_VALUES[board.piece_type_at(square) - 1] for square in scan_reversed(board.occupied))\n    return (phase * 256 + (TOTAL_PHASE / 2)) / TOTAL_PHASE",
        "detail": "cow._pesto_evaluation",
        "documentation": {}
    },
    {
        "label": "get_move_static_score",
        "kind": 2,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "def get_move_static_score(board: Board, move: Move) -> int:\n    piece = board.piece_at(move.from_square)\n    if piece.color:\n        return PIECES[piece.piece_type - 1][move.to_square] - PIECES[piece.piece_type - 1][move.from_square]\n    return PIECES[piece.piece_type - 1][move.to_square ^ 56] - PIECES[piece.piece_type - 1][move.from_square ^ 56]",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "KNIGHT_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "KNIGHT_TABLE = [-50,-40,-30,-30,-30,-30,-40,-50,\n                -40,-20,  0,  0,  0,  0,-20,-40,\n                -30,  0, 10, 15, 15, 10,  0,-30,\n                -30,  5, 15, 20, 20, 15,  5,-30,\n                -30,  0, 15, 20, 20, 15,  0,-30,\n                -30,  5, 10, 15, 15, 10,  5,-30,\n                -40,-20,  0,  5,  5,  0,-20,-40,\n                -50,-40,-30,-30,-30,-30,-40,-50,]\nBISHOP_TABLE = [-20,-10,-10,-10,-10,-10,-10,-20,\n                -10,  0,  0,  0,  0,  0,  0,-10,",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "BISHOP_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "BISHOP_TABLE = [-20,-10,-10,-10,-10,-10,-10,-20,\n                -10,  0,  0,  0,  0,  0,  0,-10,\n                -10,  0,  5, 10, 10,  5,  0,-10,\n                -10,  5,  5, 10, 10,  5,  5,-10,\n                -10,  0, 10, 10, 10, 10,  0,-10,\n                -10, 10, 10, 10, 10, 10, 10,-10,\n                -10,  5,  0,  0,  0,  0,  5,-10,\n                -20,-10,-10,-10,-10,-10,-10,-20,]\nROOK_TABLE =   [0,  0,  0,  0,  0,  0,  0,  0,\n                5, 10, 10, 10, 10, 10, 10,  5,",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "ROOK_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "ROOK_TABLE =   [0,  0,  0,  0,  0,  0,  0,  0,\n                5, 10, 10, 10, 10, 10, 10,  5,\n               -5,  0,  0,  0,  0,  0,  0, -5,\n               -5,  0,  0,  0,  0,  0,  0, -5,\n               -5,  0,  0,  0,  0,  0,  0, -5,\n               -5,  0,  0,  0,  0,  0,  0, -5,\n               -5,  0,  0,  0,  0,  0,  0, -5,\n                0,  0,  0,  5,  5,  0,  0,  0]\nQUEEN_TABLE = [-20,-10,-10, -5, -5,-10,-10,-20,\n               -10,  0,  0,  0,  0,  0,  0,-10,",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "QUEEN_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "QUEEN_TABLE = [-20,-10,-10, -5, -5,-10,-10,-20,\n               -10,  0,  0,  0,  0,  0,  0,-10,\n               -10,  0,  5,  5,  5,  5,  0,-10,\n                -5,  0,  5,  5,  5,  5,  0, -5,\n                 0,  0,  5,  5,  5,  5,  0, -5,\n               -10,  5,  5,  5,  5,  5,  0,-10,\n               -10,  0,  5,  0,  0,  0,  0,-10,\n               -20,-10,-10, -5, -5,-10,-10,-20]\nPAWN_TABLE =  [0,  0,  0,  0,  0,  0,  0,  0,\n              50, 50, 50, 50, 50, 50, 50, 50,",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "PAWN_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "PAWN_TABLE =  [0,  0,  0,  0,  0,  0,  0,  0,\n              50, 50, 50, 50, 50, 50, 50, 50,\n              10, 10, 20, 30, 30, 20, 10, 10,\n               5,  5, 10, 25, 25, 10,  5,  5,\n               0,  0,  0, 20, 20,  0,  0,  0,\n               5, -5,-10,  0,  0,-10, -5,  5,\n               5, 10, 10,-20,-20, 10, 10,  5,\n               0,  0,  0,  0,  0,  0,  0,  0]\nKING_TABLE = [-50,-40,-30,-20,-20,-30,-40,-50,\n              -30,-20,-10,  0,  0,-10,-20,-30,",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "KING_TABLE",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "KING_TABLE = [-50,-40,-30,-20,-20,-30,-40,-50,\n              -30,-20,-10,  0,  0,-10,-20,-30,\n              -30,-10, 10, 15, 15, 10,-10,-30,\n              -30,-10, 15, 20, 20, 15,-10,-30,\n              -30,-10, 15, 20, 20, 15,-10,-30,\n              -30,-10, 10, 10, 10, 10,-10,-30,\n               15, 15,  0,  0,  0,  0, 15, 15,\n               15, 20, 10,  0,  0, 10, 20, 15]\nPIECES = [PAWN_TABLE, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE]\ndef get_move_static_score(board: Board, move: Move) -> int:",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "PIECES",
        "kind": 5,
        "importPath": "cow._piece_evaluation",
        "description": "cow._piece_evaluation",
        "peekOfCode": "PIECES = [PAWN_TABLE, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE]\ndef get_move_static_score(board: Board, move: Move) -> int:\n    piece = board.piece_at(move.from_square)\n    if piece.color:\n        return PIECES[piece.piece_type - 1][move.to_square] - PIECES[piece.piece_type - 1][move.from_square]\n    return PIECES[piece.piece_type - 1][move.to_square ^ 56] - PIECES[piece.piece_type - 1][move.from_square ^ 56]",
        "detail": "cow._piece_evaluation",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 6,
        "importPath": "GUI.Board",
        "description": "GUI.Board",
        "peekOfCode": "class board:\n    def __init__(self, width, height, player):\n        self.width = width\n        self.height = height\n        self.square_height = height // 8\n        self.square_width = width // 8\n        self.selected_piece = None\n        self.promotion = None\n        self.list_valid_moves = []\n        self.board = chess.Board() ",
        "detail": "GUI.Board",
        "documentation": {}
    },
    {
        "label": "unicode_to_algebraic",
        "kind": 5,
        "importPath": "GUI.Board",
        "description": "GUI.Board",
        "peekOfCode": "unicode_to_algebraic = {\n    '♚': 'K', '♛': 'Q', '♜': 'R', '♝': 'B', '♞': 'N', '♟': 'P',\n    '♔': 'k', '♕': 'q', '♖': 'r', '♗': 'b', '♘': 'n', '♙': 'p'\n}\npromotion_code = ['q', 'r', 'b', 'n']\npromotion_list = ['queen', 'rook', 'bishop', 'knight']\nclass board:\n    def __init__(self, width, height, player):\n        self.width = width\n        self.height = height",
        "detail": "GUI.Board",
        "documentation": {}
    },
    {
        "label": "promotion_code",
        "kind": 5,
        "importPath": "GUI.Board",
        "description": "GUI.Board",
        "peekOfCode": "promotion_code = ['q', 'r', 'b', 'n']\npromotion_list = ['queen', 'rook', 'bishop', 'knight']\nclass board:\n    def __init__(self, width, height, player):\n        self.width = width\n        self.height = height\n        self.square_height = height // 8\n        self.square_width = width // 8\n        self.selected_piece = None\n        self.promotion = None",
        "detail": "GUI.Board",
        "documentation": {}
    },
    {
        "label": "promotion_list",
        "kind": 5,
        "importPath": "GUI.Board",
        "description": "GUI.Board",
        "peekOfCode": "promotion_list = ['queen', 'rook', 'bishop', 'knight']\nclass board:\n    def __init__(self, width, height, player):\n        self.width = width\n        self.height = height\n        self.square_height = height // 8\n        self.square_width = width // 8\n        self.selected_piece = None\n        self.promotion = None\n        self.list_valid_moves = []",
        "detail": "GUI.Board",
        "documentation": {}
    },
    {
        "label": "draw_board",
        "kind": 2,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "def draw_board(board, screen):\n    board.update()\n    background_img = pygame.image.load('data/imgs/background-main.jpg')\n    background_img = pygame.transform.scale(background_img, (screen.get_width() - board.width, screen.get_height()))\n    # draw background\n    screen.blit(background_img, (board.width, 0))\n    for x in range(8):\n        for y in range(8):\n            loc = (x * (board.square_width), y * (board.square_height))\n            color = 'light' if (x + y) % 2 == 1 else 'dark'",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "render_valid_moves",
        "kind": 2,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "def render_valid_moves(board, screen): #render\n        for move in board.list_valid_moves:\n            if move != board.selected_piece:\n                square_center = (move[1] * board.square_width + board.square_width // 2, \n                move[0] * board.square_height + board.square_height // 2)\n                pygame.draw.circle(screen, (255, 255, 100), square_center, board.square_width // 5.5)\ndef add_text(screen, pos, text, color=(0, 0, 0), backgroundColor=(255, 255, 255), button=False):\n    title = pygame.font.SysFont('Arial', 25).render(text, True, color)\n    temp_surface = pygame.Surface(title.get_size())\n    temp_surface.fill(backgroundColor)",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "add_text",
        "kind": 2,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "def add_text(screen, pos, text, color=(0, 0, 0), backgroundColor=(255, 255, 255), button=False):\n    title = pygame.font.SysFont('Arial', 25).render(text, True, color)\n    temp_surface = pygame.Surface(title.get_size())\n    temp_surface.fill(backgroundColor)\n    temp_surface.blit(title, (0, 0))\n    screen.blit(temp_surface, (pos[0], pos[1]))\ndef draw_promotion(board, screen):\n    team = 'white' if board.board.turn == chess.WHITE else 'black'\n    for i in range(4):\n        loc = board.square_height * i",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "draw_promotion",
        "kind": 2,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "def draw_promotion(board, screen):\n    team = 'white' if board.board.turn == chess.WHITE else 'black'\n    for i in range(4):\n        loc = board.square_height * i\n        draw_color = (0, 0, 0)\n        rect = pygame.Rect(600 + 20, loc + i * 2, board.square_width, board.square_height)\n        pygame.draw.rect(screen, draw_color, rect, 2)\n        img_path = f'./data/imgs/{team}-{promotion_list[i]}.png'\n        dude_path = os.path.join(img_path)\n        image = pygame.image.load(dude_path)",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "unicode_to_algebraic",
        "kind": 5,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "unicode_to_algebraic = {\n    '♚': 'K', '♛': 'Q', '♜': 'R', '♝': 'B', '♞': 'N', '♟': 'P',\n    '♔': 'k', '♕': 'q', '♖': 'r', '♗': 'b', '♘': 'n', '♙': 'p'\n}\npromotion_list = ['queen', 'rook', 'bishop', 'knight']\ndef draw_board(board, screen):\n    board.update()\n    background_img = pygame.image.load('data/imgs/background-main.jpg')\n    background_img = pygame.transform.scale(background_img, (screen.get_width() - board.width, screen.get_height()))\n    # draw background",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "promotion_list",
        "kind": 5,
        "importPath": "GUI.board_graphics",
        "description": "GUI.board_graphics",
        "peekOfCode": "promotion_list = ['queen', 'rook', 'bishop', 'knight']\ndef draw_board(board, screen):\n    board.update()\n    background_img = pygame.image.load('data/imgs/background-main.jpg')\n    background_img = pygame.transform.scale(background_img, (screen.get_width() - board.width, screen.get_height()))\n    # draw background\n    screen.blit(background_img, (board.width, 0))\n    for x in range(8):\n        for y in range(8):\n            loc = (x * (board.square_width), y * (board.square_height))",
        "detail": "GUI.board_graphics",
        "documentation": {}
    },
    {
        "label": "Piece",
        "kind": 6,
        "importPath": "GUI.piece",
        "description": "GUI.piece",
        "peekOfCode": "class Piece(pygame.sprite.Sprite):\n    def __init__(self, piece_code, team_code, square_width, square_height):\n        super().__init__()\n        self.piece_code = piece_code\n        self.team_code = team_code\n        self.image = self.load_image(piece_code, team_code, square_width, square_height)\n        self.rect = self.image.get_rect()\n    def load_image(self, piece_code, team_code, square_width, square_height):\n        piece_str = self.get_piece_string(piece_code)\n        img_path = f'./data/imgs/{team_code}-{piece_str}.png'",
        "detail": "GUI.piece",
        "documentation": {}
    },
    {
        "label": "EndGameWindow",
        "kind": 6,
        "importPath": "end_window",
        "description": "end_window",
        "peekOfCode": "class EndGameWindow:\n    def __init__(self, window_size, result):\n        self.window_size = window_size\n        self.result = result\n        self.font = pygame.font.Font(None, 36)\n    def draw_window(self, screen):\n        screen.fill('white')\n        text_surface = self.font.render(self.result, True, 'black')\n        text_rect = text_surface.get_rect()\n        text_rect.center = (self.window_size[0] // 2, self.window_size[1] // 2)",
        "detail": "end_window",
        "documentation": {}
    },
    {
        "label": "draw_start_screen",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)\n    pygame.display.update()\nwhile True:\n    mx, my = pygame.mouse.get_pos()\n    for event in pygame.event.get(): \n        if event.type == pygame.QUIT:\n            exit()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "draw",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def draw(screen):\n    screen.fill('white')\n    draw_board(main_board, screen)\n    pygame.display.update()\ndef is_end_game(board):\n    if board.is_checkmate():\n        if board.turn == chess.WHITE:\n            return True, \"Black wins by checkmate!\"\n        else:\n            return True, \"White wins by checkmate!\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "is_end_game",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def is_end_game(board):\n    if board.is_checkmate():\n        if board.turn == chess.WHITE:\n            return True, \"Black wins by checkmate!\"\n        else:\n            return True, \"White wins by checkmate!\"\n    elif board.is_stalemate():\n        return True, \"Stalemate!\"\n    elif board.is_insufficient_material():\n        return True, \"Insufficient material for checkmate.\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "window_size",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "window_size = (800, 600)\nboard_size = (600, 600)\nteam = [-1, -1]\n# start screen\nscreen = pygame.display.set_mode(window_size)\nmain_start_screen = start_screen(window_size)\ndef draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "board_size",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "board_size = (600, 600)\nteam = [-1, -1]\n# start screen\nscreen = pygame.display.set_mode(window_size)\nmain_start_screen = start_screen(window_size)\ndef draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)\n    pygame.display.update()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "team",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "team = [-1, -1]\n# start screen\nscreen = pygame.display.set_mode(window_size)\nmain_start_screen = start_screen(window_size)\ndef draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)\n    pygame.display.update()\nwhile True:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "screen = pygame.display.set_mode(window_size)\nmain_start_screen = start_screen(window_size)\ndef draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)\n    pygame.display.update()\nwhile True:\n    mx, my = pygame.mouse.get_pos()\n    for event in pygame.event.get(): ",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main_start_screen",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "main_start_screen = start_screen(window_size)\ndef draw_start_screen(screen):\n    #screen.blit(background, (0, 0))\n    screen.fill('white')\n    main_start_screen.draw_screen(screen)\n    pygame.display.update()\nwhile True:\n    mx, my = pygame.mouse.get_pos()\n    for event in pygame.event.get(): \n        if event.type == pygame.QUIT:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main_board",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "main_board = board(board_size[0], board_size[1], team)\ndef draw(screen):\n    screen.fill('white')\n    draw_board(main_board, screen)\n    pygame.display.update()\ndef is_end_game(board):\n    if board.is_checkmate():\n        if board.turn == chess.WHITE:\n            return True, \"Black wins by checkmate!\"\n        else:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "best_move",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "best_move = -1\n###### Game loop ######\nalphazero = AlphaZeroAI()\nwhile True:\n    mx, my = pygame.mouse.get_pos()\n    for event in pygame.event.get(): \n        if event.type == pygame.QUIT:\n            exit()\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            if event.button == 1:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "alphazero",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "alphazero = AlphaZeroAI()\nwhile True:\n    mx, my = pygame.mouse.get_pos()\n    for event in pygame.event.get(): \n        if event.type == pygame.QUIT:\n            exit()\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            if event.button == 1:\n                if main_board.player[main_board.turn]:\n                    main_board.player_click(mx, my, screen)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "start_screen",
        "kind": 6,
        "importPath": "start_window",
        "description": "start_window",
        "peekOfCode": "class start_screen:\n    def __init__(self, window_size):\n        self.max_width, self.max_height = window_size\n        self.font = pygame.font.SysFont('Arial', 25)\n        self.buttons = []\n        self.mode = [(1, 1, 0), (0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1)]\n    def draw_screen(self, screen):\n        self.addTextTitle(screen, (self.max_width // 2, self.max_height // 4.8), \"Chess Game\", 1)\n        self.addText(screen, (self.max_width // 2, (self.max_height // 1.65)), \"   Player vs Bot    \")\n        self.addTextTitle(screen, (self.max_width // 2, (self.max_height // 1.43)), \"   Please choose your opponent    \", 0)",
        "detail": "start_window",
        "documentation": {}
    }
]